# Implementation Tasks: Global Usage Tracking

## Phase 1: Core Infrastructure (Foundational)

### Task 1: Create usage tracking types
- [ ] Create `src/usage-tracking-config.ts` file
- [ ] Define `UsageTrackingEvent` interface with all required fields
- [ ] Define `UsageTrackingHandler` type (function signature)
- [ ] Define `UsageTrackingConfig` interface with `onUsage` and optional `onError`
- [ ] Export all types from main index

**Dependencies**: None
**Validation**: Type definitions compile without errors

### Task 2: Implement global configuration storage
- [ ] Add module-level variable `globalUsageTrackingConfig: UsageTrackingConfig | null`
- [ ] Implement `configureUsageTracking(config: UsageTrackingConfig | UsageTrackingHandler): void`
- [ ] Handle shorthand: if config is function, wrap as `{ onUsage: config }`
- [ ] Implement `resetUsageTracking(): void` to clear config
- [ ] Implement `getUsageTrackingConfig(): UsageTrackingConfig | null` internal helper

**Dependencies**: Task 1
**Validation**: Can set and retrieve config, reset clears it

### Task 3: Implement event builder helper
- [ ] Add private method `buildUsageEvent()` to Agent class
- [ ] Extract `sessionId` from execution context if present
- [ ] Extract `_handoffChain` from execution context if present
- [ ] Build event with agent name, method, usage, providerMetadata, context
- [ ] Handle both generate and stream event structures

**Dependencies**: Task 1, Task 2
**Validation**: Event built correctly with all available fields

## Phase 2: Agent.generate() Integration

### Task 4: Add tracking to Agent.generate()
- [ ] Import `getUsageTrackingConfig` in agent.ts
- [ ] Add `const startTime = Date.now()` at start of `generate()` method
- [ ] After successful generation, check if tracker configured
- [ ] Build `UsageTrackingEvent` with `method: 'generate'`
- [ ] Calculate duration: `duration: Date.now() - startTime`
- [ ] Invoke tracking handler with try/catch

**Dependencies**: Task 3
**Validation**: Manual test shows tracking invoked after generate()

### Task 5: Add error handling for generate() tracking
- [ ] Wrap tracking call in try/catch block
- [ ] If `onError` callback exists, invoke it with error and event
- [ ] Otherwise, use logger.error() for silent logging
- [ ] Ensure generation result is still returned on tracking failure

**Dependencies**: Task 4
**Validation**: Tracking errors don't break generation

## Phase 3: Agent.stream() Integration

### Task 6: Add tracking to Agent.stream()
- [ ] Get global tracker at start of `stream()` method
- [ ] Extract user's `onFinish` from options (if present)
- [ ] If tracker exists, create composed `onFinish` callback
- [ ] Composed callback runs both user callback and tracker in parallel (Promise.all)
- [ ] Pass composed callback to underlying AI SDK stream()

**Dependencies**: Task 3
**Validation**: Both user callback and tracker invoked

### Task 7: Handle stream() tracking event building
- [ ] Build `UsageTrackingEvent` in stream's onFinish context
- [ ] Set `method: 'stream'`
- [ ] Extract usage and providerMetadata from finish event
- [ ] Do NOT include duration (streaming time tracked by user if needed)
- [ ] Include execution context if available

**Dependencies**: Task 6
**Validation**: Event contains correct stream-specific data

### Task 8: Add error handling for stream() tracking
- [ ] Wrap tracking call in try/catch within composed onFinish
- [ ] If `onError` exists, invoke it
- [ ] Otherwise, use logger.error()
- [ ] Ensure user's onFinish still executes even if tracking fails

**Dependencies**: Task 6, Task 7
**Validation**: Tracking errors don't prevent user callback

## Phase 4: Multi-Agent Handoff Tracking

### Task 9: Propagate handoff chain through context
- [ ] In handoff logic, check if execution context has `_handoffChain`
- [ ] If not, initialize as empty array
- [ ] Append current agent name before handing off
- [ ] Ensure chain is passed to next agent's execution context

**Dependencies**: None (handoff logic exists)
**Validation**: Chain builds correctly through handoffs

### Task 10: Include handoff chain in tracking events
- [ ] In `buildUsageEvent()`, extract `_handoffChain` from context
- [ ] Add current agent name to chain for tracking event
- [ ] Set `handoffChain` field in event
- [ ] Handle case where chain is undefined (single agent, no handoffs)

**Dependencies**: Task 3, Task 9
**Validation**: Each agent tracked with full chain context

## Phase 5: Examples and Documentation

### Task 11: Create basic usage example
- [ ] Create `src/examples/usage-tracking/basic-tracking.ts`
- [ ] Show `configureUsageTracking` with simple console.log handler
- [ ] Demonstrate tracking with `agent.generate()`
- [ ] Demonstrate tracking with `agent.stream()`
- [ ] Show that both methods automatically track

**Dependencies**: Task 4, Task 6
**Validation**: Example runs and logs tracking events

### Task 12: Create persistence example (OpenRouter + DB)
- [ ] Create `src/examples/usage-tracking/database-persistence.ts`
- [ ] Show extracting OpenRouter cost from providerMetadata
- [ ] Demonstrate async persistence (simulated DB call)
- [ ] Show error handling with `onError` callback
- [ ] Include comments about real DB integration

**Dependencies**: Task 4, Task 6
**Validation**: Example demonstrates real-world pattern

### Task 13: Create multi-agent handoff example
- [ ] Create `src/examples/usage-tracking/multi-agent-tracking.ts`
- [ ] Create 2-3 agent handoff chain
- [ ] Configure global tracking
- [ ] Run workflow and show each agent tracked separately
- [ ] Display handoffChain in console output

**Dependencies**: Task 10
**Validation**: Shows per-agent tracking with chain context

### Task 14: Write usage tracking guide
- [ ] Create `/docs/guides/usage-tracking-configuration.md`
- [ ] Explain motivation (eliminate repetition)
- [ ] Document `configureUsageTracking` API with examples
- [ ] Document `UsageTrackingEvent` structure
- [ ] Show OpenRouter integration pattern
- [ ] Document error handling behavior
- [ ] Add troubleshooting section

**Dependencies**: All implementation tasks
**Validation**: Guide is clear and comprehensive

### Task 15: Update main README
- [ ] Add "Usage Tracking" section to agents README
- [ ] Quick example showing global config
- [ ] Link to comprehensive guide
- [ ] Note that it works with all providers

**Dependencies**: Task 14
**Validation**: README clearly explains new feature

### Task 16: Update CHANGELOG
- [ ] Add entry under "## Unreleased" → "### Added"
- [ ] Document `configureUsageTracking` and `resetUsageTracking` functions
- [ ] Document `UsageTrackingEvent` and `UsageTrackingHandler` types
- [ ] Explain automatic tracking in generate() and stream()
- [ ] Mention multi-agent handoff tracking support

**Dependencies**: All implementation tasks
**Validation**: CHANGELOG accurately describes changes

## Phase 6: Validation and Polish

### Task 17: Type-check all changes
- [ ] Run `bun run type-check` and fix any errors
- [ ] Ensure all new exports are in index.ts
- [ ] Verify types are exported from package

**Dependencies**: All implementation tasks
**Validation**: `bun run type-check` passes

### Task 18: Build and test examples
- [ ] Run `bun run build` for agents package
- [ ] Execute all three examples from Task 11-13
- [ ] Verify tracking events have expected structure
- [ ] Verify error handling works as documented

**Dependencies**: Task 17
**Validation**: All examples run successfully

### Task 19: Manual integration testing
- [ ] Test with OpenRouter provider (extract cost)
- [ ] Test with OpenAI provider (generic metadata)
- [ ] Test with Anthropic provider (generic metadata)
- [ ] Verify sessionId extraction from context
- [ ] Verify tracking with no context provided

**Dependencies**: Task 18
**Validation**: Works correctly across providers

### Task 20: Update OpenSpec proposal
- [ ] Mark all tasks as completed
- [ ] Validate with `openspec validate add-global-usage-tracking --strict`
- [ ] Resolve any validation errors
- [ ] Ensure spec scenarios match implementation

**Dependencies**: All tasks
**Validation**: `openspec validate` passes

## Parallelizable Work

- **Phase 1** (Tasks 1-3): Must be sequential (foundational)
- **Phase 2** (Tasks 4-5) and **Phase 3** (Tasks 6-8): Can be parallel after Phase 1
- **Phase 4** (Tasks 9-10): Can start after Task 3
- **Phase 5** (Tasks 11-16): Can start after Phases 2-4 complete
- **Phase 6** (Tasks 17-20): Must be sequential (validation)

## Success Criteria

- ✅ Global tracking configured once, works for all agents
- ✅ Automatic tracking in generate() and stream()
- ✅ Multi-agent handoffs tracked per-agent
- ✅ Error handling prevents tracking from breaking generation
- ✅ Type-safe APIs with full TypeScript support
- ✅ Comprehensive examples and documentation
- ✅ All type checks and builds pass
- ✅ OpenSpec validation passes
